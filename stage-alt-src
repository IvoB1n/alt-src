#!/usr/bin/python

import ConfigParser
import datetime
import logging
import koji
from optparse import OptionParser
import os
import os.path
import re
import rpm
import shutil
import subprocess
import sys
import tempfile



'''
Given an srpm and product, stage for alt-src release
'''


def _(args):
    """Stub function for translation"""
    return args


def get_options():
    """process options from command line"""

    usage = _("%prog [options] branch srpm")
    parser = OptionParser(usage=usage)
    parser.add_option("-c", "--config", dest="cfile", default='/etc/altsrc.conf',
                      help=_("use alternate configuration file"), metavar="FILE")
    parser.add_option("-v", "--verbose", action="store_true", default=False,
                      help=_("be more verbose"))
    parser.add_option("-q", "--quiet", action="store_true", default=False,
                      help=_("be less verbose"))
    parser.add_option("-d", "--debug", action="store_true", default=False,
                      help=_("show debug output"))
    parser.add_option("--force", action="store_true", default=False,
                      help=_("force operation"))
    parser.add_option("-o", "--option", dest="copts", action="append", metavar="OPT=VALUE",
                      help=_("set config option"))
    (options, args) = parser.parse_args()

    options.branch = args[0]
    options.source = args[1]

    options.config = get_config(options.cfile, options.copts)

    return options


config_defaults = {
    'stagedir' : '/srv/alt-src-stage',
    'gitdir' : '/srv/git',
    'rulesdir' : '/var/lib/altsrc/rules',
    'lookaside' : '/srv/cache/lookaside',
    'log_level' : 'WARN',
    'log_file' : None,
    'log_format' : '%(asctime)s [%(levelname)s] %(message)s',
    'whitelist' : '',
    'blacklist' : '',
    'changelog_user' : 'sources@centos.org',
}

config_int_opts = set()
config_bool_opts = set()

def get_config(cfile, overrides):
    if not os.access(cfile, os.F_OK):
        die("Missing config file: %s" % cfile)
    cp = ConfigParser.RawConfigParser()
    cp.read(cfile)
    if not cp.has_section('altsrc'):
        die("Configuration file missing [altsrc] section: %s" % cfile)

    #apply overrides from command line
    overrides = overrides or []
    for opt in overrides:
        parts = opt.split("=", 1)
        if len(parts) != 2:
            die('Invalid option specification: %s\nUse OPT=VALUE' % opt)
        key, value = parts
        cp.set('altsrc', key, value)

    #generate config dictionary
    config = dict(config_defaults)  #copy
    for key in cp.options('altsrc'):
        if key in config_int_opts:
            config[key] = cp.getint('altsrc', key)
        elif key in config_bool_opts:
            config[key] = cp.getboolean('altsrc', key)
        else:
            config[key] = cp.get('altsrc', key)

    #sanity checks
    if not os.path.isdir(config['stagedir']):
        die("No such directory: %s" % config['stagedir'])

    return config



class SpecFile(object):
    '''
        Spec manipulation functions
        Based on similar class from python-rpmpatch
        https://cdcvs.fnal.gov/redmine/projects/python-rpmpatch/
    '''

    def __init__(self, specfile, changelog_user):
        '''
            Read in the specfile and setup our environment
        '''
        self.specfile = specfile

        self.changelog_user = changelog_user
        self.changelog = {}

        self.changelog_done = False

        self.text = None

        _fd = open(self.specfile, 'r')
        self.text = _fd.read()
        _fd.close()

        basedir = os.path.dirname(self.specfile)
        self.basedir = basedir
        self.sourcesdir = os.path.abspath(basedir + '/../SOURCES/')
        if os.path.isfile(self.sourcesdir + '/' + self.specfile):
            os.remove(self.sourcesdir + '/' + self.specfile)
        shutil.copy2(self.specfile, self.sourcesdir)

    def __del__(self):
        '''
            Make sure to save changes
        '''
        if self.text != None:
            self.save()

    def run_re(self, regex_match, regex_replace, changelog):
        '''
            Run a regex against the specfile
        '''
        self.text = re.sub(regex_match, regex_replace, self.text)

        regname = regex_match + ' => ' + regex_replace

        self.changelog['Ran Regex: ' + regname] = changelog

        return True

    def apply_specfile_diff(self, spec_patch, changelog):
        '''
            For any actual changes to the specfile you will need to generate
            a nice simple unified diff summarizing your changes.  The diff will
            be automatically added to the SRPM as a 'SOURCE' file so that you
            can easily review your changes in the future.

            This is not pure python. http://bugs.python.org/issue2057

            Your patch must have a stripe of '0' or things wont work right.
            Rather than accounting for all use cases I'm just forcing a simple
            one so you will have to deal with it.
        '''
        tempdir = tempfile.mkdtemp()
        specname = os.path.basename(self.specfile)
        _fd = open(tempdir + '/' + specname, 'w')
        _fd.write(self.text)
        _fd.close()

        _fd = open(spec_patch, 'r')

        thisdir = os.getcwd()
        os.chdir(tempdir)
        code = subprocess.call(['patch' , '-p0'], stdin=_fd,
                               stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                               shell=True)
        _fd.close()
        if code != 0:
            raise RuntimeError(code, "Spec diff failed")

        _fd = open(tempdir + '/' + specname, 'r')
        self.text = _fd.read()
        _fd.close()

        self.add_source(spec_patch, None, changelog=changelog)

        os.chdir(thisdir)
        shutil.rmtree(tempdir)

        return True

    def add_patch(self, patchfile, patchstripe, patchnum, changelog):
        '''
            This will add a given patch into the rpm package.  You must
            specify the patch stripe (the 1 from -p1).

            A unique number is required for the patchnum.
            You can specify one or set it to 'None' and a somewhat random,
            though unique, number will be created for you.

            You must provide a changelog reason for this modification.
        '''
        patch_re = '([pP]atch(\d*):\s+(\S+))'
        matches = re.findall(patch_re, self.text)
        # if we are making a number up
        if patchnum == None:
            # if there are no existing patches we start at 0, else at 1
            if not matches:
                patchnum_list = [ 0 ]
            else:
                patchnum_list = [ 1 ]

            # put all the numbers in a list
            for match in matches:
                if match[1]:
                    patchnum_list.append(int(match[1]))

        # find the biggest num and + 1
        patchnum = (max(patchnum_list) + 1)

        patchname = os.path.basename(patchfile)
        if os.path.isfile(self.basedir + '/../SOURCES/' + patchname):
            os.remove(self.basedir + '/../SOURCES/' + patchname)
        shutil.copy2(patchfile, self.sourcesdir)
        entry = "\nPatch" + str(patchnum) + ":\t" + patchname

        matches = re.findall(patch_re, self.text)
        if matches:
            patch_entry = matches[-1][0]
        else:
            namematch = re.findall('(\s*[nN]ame:\s+.*)', self.text)
            patch_entry = namematch[0]

        self.text = self.text.replace(patch_entry, patch_entry + entry)

        entry = "\n%patch" + str(patchnum) + ' -p' + str(patchstripe)
        patch_re = '(%patch\d+\s+-p\d.*)'
        matches = re.findall(patch_re, self.text)
        if matches:
            patch_entry = matches[-1]
        else:
            setup_re = '(%setup.*)'
            matches = re.findall(setup_re, self.text)
            patch_entry = matches[0]

        self.text = self.text.replace(patch_entry, patch_entry + entry)

        self.changelog['Added Patch: ' + patchname] = changelog

        return (patchnum, patchname)

    def rm_patch(self, patchname, patchnum, changelog):
        '''
            Prevent a given patch from being applied to the rpm package.

            You can describe the patch by name or by number, but you
            must pick one!  Set the other to 'None'

            You must provide a changelog reason for this modification.
        '''

        if patchname != None:
            patch_re = '(\s*[pP]atch(\d+):\s+(' + patchname + ')\n)'
        elif patchnum != None:
            patch_re = '(\s*[pP]atch(' + str(patchnum) + '):\s+(\S+?)\s+?)'
        else:
            raise ValueError('You must specify something I can use here')

        matches = re.findall(patch_re, self.text)
        self.text = self.text.replace(matches[0][0], '\n')

        patchnum = matches[0][1]
        patchname = matches[0][2]

        patch_re = '(%patch' + patchnum + '.+?\n)'
        match_patch = re.findall(patch_re, self.text)
        self.text = self.text.replace(match_patch[0], '\n')

        self.changelog['Removed Patch: ' + patchname] = changelog

        return (patchnum, patchname)

    def add_source(self, sourcefile, sourcenum, changelog):
        '''
            Add a source file to the rpm spec.

            A unique number is required for the sourcenum.
            You can specify one or set it to 'None' and a somewhat random,
            though unique, number will be created for you.

            You must provide a changelog reason for this modification.
        '''
        source_re = '([sS]ource(\d*):\s+(\S+))'
        matches = re.findall(source_re, self.text)
        # if we are making a number up
        if sourcenum == None:
            # if there are no existing sources we start at 0, else at 1
            if not matches:
                sourcenum_list = [ 0 ]
            else:
                sourcenum_list = [ 1 ]

            # put all the numbers in a list
            for match in matches:
                if match[1]:
                    sourcenum_list.append(int(match[1]))

        # find the biggest num and + 1
        sourcenum = (max(sourcenum_list) + 1)

        sourcename = os.path.basename(sourcefile)
        if os.path.isfile(self.basedir + '/../SOURCES/' + sourcename):
            os.remove(self.basedir + '/../SOURCES/' + sourcename)
        shutil.copy2(sourcefile, self.sourcesdir)
        entry = "\nSource" + str(sourcenum) + ":\t" + sourcename

        matches = re.findall(source_re, self.text)
        if matches:
            source_entry = matches[-1][0]
        else:
            namematch = re.findall('(\s*[nN]ame:\s+.+)', self.text)
            source_entry = namematch[0]

        self.text = self.text.replace(source_entry, source_entry + entry)

        self.changelog['Added Source: ' + sourcename] = changelog

        return (sourcenum, sourcename)

    def __add_changelog(self):
        '''
            Record the changes in the changelog
        '''
        if self.changelog_done == True:
            return
        now = datetime.datetime.now().strftime('%a %b %d %Y ')
        changelog_text = '%changelog\n* ' + now + self.changelog_user + '\n'
        for action in self.changelog.keys():
            changelog_text = changelog_text + '- ' + action + '\n'
            changelog_text = changelog_text + '-->  ' + self.changelog[action]
            changelog_text = changelog_text + '\n'

        changelog_text = changelog_text + '\n'

        self.text = self.text.replace('%changelog\n', changelog_text)

        self.changelog_done = True

        return True

    def save(self):
        '''
            Write out the specfile with changes
        '''
        self.__add_changelog()
        _fd = open(self.specfile, 'w')
        _fd.write(self.text)
        _fd.close()

        return True


class Stager(object):

    def __init__(self, options):
        self.options = options
        self.logger = logging.getLogger("altsrc")
        self.srpm = options.source
        #TODO - support pulling srpm from Brew
        if not os.path.isfile(self.srpm):
            die("No such file: %s", self.srpm)

    def run(self):
        self.read_srpm()
        self.check_package()
        self.make_workdir()
        self.sync_repo()
        self.clone_repo()
        self.setup_checkout()
        self.import_srpm()
        self.debrand()
        self.clear_checkout()
        self.notify()

    def read_srpm(self):
        self.logger.info('Reading source rpm: %s', self.srpm)
        h = koji.get_rpm_header(self.srpm)
        self.headers = h
        if h[rpm.RPMTAG_SOURCEPACKAGE] != 1:
            die("%s is not a source package" % self.srpm)
        data = koji.get_header_fields(h, ['name','version','release'])
        self.nvr = "%(name)s-%(version)s-%(release)s" % data
        self.package = data['name']
        self.version = data['version']

    def check_package(self):
        """Check whitelist/blacklist and load any package rules"""

        whitelist = self.options.config['whitelist'].split()
        if whitelist:
            whitelisted = koji.util.multi_fnmatch(self.package, whitelist)
        else:
            whitelisted = False
        if not whitelisted:
            blacklist = self.options.config['blacklist'].split()
            if blacklist and koji.util.multi_fnmatch(self.package, blacklist):
                die('Blacklisted package: %s' % self.package)

    def make_workdir(self):
        dirname = os.path.join(self.options.config['stagedir'], self.nvr)
        letter = self.package[0]
        if not letter.isalpha():
            letter = "_"
        parts = [
            os.path.join(self.options.config['stagedir']),
            letter,
            self.package,
            self.nvr,
        ]
        dirname = os.path.join(*parts)
        self.logger.info('Creating working directory: %s', dirname)
        if os.path.islink(dirname):
            die("%s is a symlink" % dirname)
        elif os.path.isdir(dirname):
            # TODO - more sanity checks
            if self.options.force:
                self.logger.warn("Overwriting existing workdir: %s",  dirname)
                # TODO - back up first
                koji.util.rmtree(dirname)
            else:
                die("Work directory %s directory exists, use --force to overwrite." % dirname)
        elif os.path.exists(dirname):
            die("%s exists and is not a directory" % dirname)
        koji.ensuredir(dirname)
        self.workdir = dirname

    def sync_repo(self):
        # TODO
        pass

    def clone_repo(self):
        """Clone master repo into working directory"""
        logname = os.path.join(self.workdir, 'clone.log')
        fo = file(logname, 'wb')
        src = os.path.join(self.options.config['gitdir'], "%s.git" % self.package)
        dst = os.path.join(self.workdir, "%s.git" % self.package)
        self.logger.info('Cloning primary %s repo from %s', self.package, src)
        cmd = ['git', 'clone', '--shared', '--bare', '-v', src, dst]
        # is --shared ok for us?
        # TODO - template? git config?
        # TODO - committer data?
        proc = subprocess.Popen(cmd, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        ret = proc.wait()
        if ret:
            die("command failed: %r" % cmd)

    def setup_checkout(self):
        """Setup a temporary non-bare checkout to work with"""

        logname = os.path.join(self.workdir, 'checkout.log')
        fo = file(logname, 'wb')

        src = os.path.join(self.workdir, "%s.git" % self.package)
        dst = os.path.join(self.workdir, "tmp.%s" % self.package)
        self.checkout = dst
        self.logger.info('Setting up temporary checkout: %s', dst)
        cmd = ['git', 'clone', '--local', '-v', src, dst]
        proc = subprocess.Popen(cmd, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        proc.wait() and die("command failed: %r" % cmd)

        #switch branch
        self.logger.info('Switching to branch %s', self.options.branch)
        #TODO - smarter sanity checks
        cmd = ['git', 'checkout', self.options.branch]
        #XXX - should be more paranoid here
        proc = subprocess.Popen(cmd, cwd=dst, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        proc.wait() and die("command failed: %r" % cmd)

    def import_srpm(self):
        """Import our srpm on the specified branch"""

        logname = os.path.join(self.workdir, 'import.log')
        fo = file(logname, 'wb')

        #explode our srpm
        dst = self.checkout
        wipe_git_dir(dst)
        explode_srpm(self.srpm, dst, logfile=fo)

        cmd = ['git', 'add', '-A', '.']
        proc = subprocess.Popen(cmd, cwd=dst, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        proc.wait() and die("command failed: %r" % cmd)

        #TODO - deal with lookaside

        cmd = ['git', 'commit', '-m', 'import %s' % self.nvr]
        proc = subprocess.Popen(cmd, cwd=dst, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        proc.wait() and die("command failed: %r" % cmd)

        #push back to our bare git directory
        cmd = ['git', 'push', 'origin', self.options.branch]
        proc = subprocess.Popen(cmd, cwd=dst, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        proc.wait() and die("command failed: %r" % cmd)


    def find_spec(self):
        """Locate specfile in checkout"""
        specdir = os.path.join(self.checkout, 'SPECS')

        #first look for $package.spec
        path = os.path.join(specdir, self.package + '.spec')
        if os.path.isfile(path):
            return path

        #otherwise
        for fn in os.listdir(specdir):
            if fn.endswith('.spec'):
                return os.path.join(specdir, fn)

        die('No spec file in checkout: %s' % self.checkout)


    def debrand(self):
        """Apply debranding rules"""
        #search for applicable rules

        cp = ConfigParser.RawConfigParser()
        for name in 'altsrc-global', self.package:
            cfile = os.path.join(self.options.config['rulesdir'], name + '.cfg')
            if not os.access(cfile, os.F_OK):
                continue
            self.logger.info('Loading rules from %s', cfile)
            cp.read(cfile)

        # order rules
        rules = []
        for section in cp.sections():
            parts = section.split(None, 1)
            if len(parts) < 2:
                continue
            rtype, key = parts
            rules.append((key, rtype, section))
        rules.sort()

        spec = SpecFile(self.find_spec(), self.options.config['changelog_user'])

        # apply rules
        for key, rtype, section in rules:
            handler = 'rule_handler_%s' % rtype
            if not hasattr(self, handler):
                die("No handler for rule type %s" % rtype)
            data = dict(cp.items(section))
            if 'enabled' in data:
                enabled = data['enabled'].lower().strip()
                if enabled in ('no', 'false', '0'):
                    self.logger.info('Skipping disabled rule: %s', section)
                    continue
            if 'on_package' in data:
                patterns = data['on_package'].split()
                if not koji.util.multi_fnmatch(self.package, patterns):
                    self.logger.debug('Skipping rule due to package filter: %s', section)
                    continue
            if 'on_version' in data:
                patterns = data['on_version'].split()
                if not koji.util.multi_fnmatch(self.version, patterns):
                    self.logger.debug('Skipping rule due to version filter: %s', section)
                    continue
            if 'on_branch' in data:
                patterns = data['on_branch'].split()
                if not koji.util.multi_fnmatch(self.options.branch, patterns):
                    self.logger.debug('Skipping rule due to branch filter: %s', section)
                    continue
            self.logger.info("Applying rule: %s", section)
            getattr(self, handler)(spec, data)
            # TODO - check result

        #TODO - commit changes

    def rule_handler_spec(self, spec, data):
        """Patch the spec file"""

        changelog = data.get('changelog')
        fn = data['patch']
        patch = os.path.join(self.options.config['rulesdir'], fn)
        spec.apply_specfile_diff(patch, changelog)

    def rule_handler_re(self, spec, data):
        """Apply a regex substitution to the spec file"""

        changelog = data.get('changelog')
        spec.run_re(data['match'], data['replace'], changelog)

    def rule_handler_patch(self, spec, data):
        """Add or remove a patch in the spec file"""

        method = data['method'].lower()
        changelog = data.get('changelog')
        num = data.get('num')
        if method == 'add':
            name = data['patch']
            stripe = data['stripe']
            specfile.add_patch(name, stripe, num, changelog)

        elif method == 'del':
            if 'patch' in data:
                name = os.path.basename(data['patch'])
            else:
                name = None

            # XXX I guess this is a common rpmpatch config typo?
            if num == name:
                die('Bad patch section in config')

            return specfile.rm_patch(name, num, changelog)


    def rule_handler_source(self, spec, data):
        """Add a source to the specfile"""

        changelog = data.get('changelog')
        method = data['method'].lower()
        num = data.get('num')
        if method == 'add':
            thisfile = data['source']
            specfile.add_source(thisfile, num, changelog)

        #XXX - no other methods??
        else:
            die('Bad source section in config file')


    def clear_checkout(self):
        """Remove our temporary checkout"""
        #koji.util.rmtree(self.checkout)
        pass #XXX


    def notify(self):
        pass
        #TODO


def explode_srpm(srpm, destdir=None, logfile=None):
    # explode our srpm to the given directory
    h = koji.get_rpm_header(srpm)
    if h[rpm.RPMTAG_SOURCEPACKAGE] != 1:
        # we checked this earlier, but since we're about to rpm -i it,
        # let's check again
        die("%s is not a source package" % srpm)
    if destdir is None:
        destdir = os.getcwd()
    else:
        destdir = os.path.abspath(destdir)
        koji.ensuredir(destdir)
    cmd = ['rpm', '--nosignature', '-i', '--define', '_topdir %s' % destdir, srpm]
    #print "Running: %r" % cmd
    popts = {'close_fds':True}
    if logfile:
        popts['stdout'] = logfile
        popts['stderr'] = subprocess.STDOUT
    proc = subprocess.Popen(cmd, **popts)
    ret = proc.wait()
    if ret:
        die("command failed: %r" % cmd)


def wipe_git_dir(dirname):
    for fn in os.listdir(dirname):
        if fn == '.git':
            continue
        path = os.path.join(dirname, fn)
        if os.path.isdir(path):
            koji.rmtree(path)
        else:
            os.unlink(path)


def die(msg):
    print msg
    sys.exit(1)


def setup_logging(options):
    logger = logging.getLogger("altsrc")
    handler = logging.StreamHandler(sys.stderr)
    handler.setFormatter(logging.Formatter(options.config['log_format']))
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    if options.config['log_file']:
        handler = logging.FileHandler(options.config['log_file'])
        handler.setFormatter(logging.Formatter(options.config['log_format']))
        handler.setLevel(logging.DEBUG)
        logger.addHandler(handler)
    level = options.config['log_level']
    if options.debug:
        level = 'DEBUG'
    elif options.verbose:
        level = 'INFO'
    elif options.quiet:
        level = 'ERROR'
    lvl = getattr(logging, level, None)
    if lvl is None:
        die("Invalid log level: %s" % options.config['log_level'])
    logger.setLevel(lvl)
    # TODO - setup koji's logger?


if __name__ == '__main__':
    options = get_options()
    setup_logging(options)
    stg = Stager(options)
    stg.run()
    #TODO - trap errors and notify

# the end
