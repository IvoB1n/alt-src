#!/usr/bin/python

import ConfigParser
import logging
import koji
from optparse import OptionParser
import os
import os.path
import rpm
import subprocess
import sys



'''
Given an srpm and product, stage for alt-src release
'''


def _(args):
    """Stub function for translation"""
    return args


def get_options():
    """process options from command line"""

    usage = _("%prog [options] branch srpm")
    parser = OptionParser(usage=usage)
    parser.add_option("-c", "--config", dest="cfile", default='/etc/altsrc.conf',
                      help=_("use alternate configuration file"), metavar="FILE")
    parser.add_option("-v", "--verbose", action="store_true", default=False,
                      help=_("be more verbose"))
    parser.add_option("-q", "--quiet", action="store_true", default=False,
                      help=_("be less verbose"))
    parser.add_option("-d", "--debug", action="store_true", default=False,
                      help=_("show debug output"))
    parser.add_option("--force", action="store_true", default=False,
                      help=_("force operation"))
    parser.add_option("-o", "--option", dest="copts", action="append", metavar="OPT=VALUE",
                      help=_("set config option"))
    (options, args) = parser.parse_args()

    options.branch = args[0]
    options.source = args[1]

    options.config = get_config(options.cfile, options.copts)

    return options


config_defaults = {
    'stagedir' : '/srv/alt-src-stage',
    'gitdir' : '/srv/git',
    'rulesdir' : '/var/lib/altsrc/rules',
    'lookaside' : '/srv/cache/lookaside',
    'log_level' : 'WARN',
    'log_file' : None,
    'log_format' : '%(asctime)s [%(levelname)s] %(message)s',
    'whitelist' : '',
    'blacklist' : '',
}

config_int_opts = set()
config_bool_opts = set()

def get_config(cfile, overrides):
    if not os.access(cfile, os.F_OK):
        die("Missing config file: %s" % cfile)
    cp = ConfigParser.RawConfigParser()
    cp.read(cfile)
    if not cp.has_section('altsrc'):
        die("Configuration file missing [altsrc] section: %s" % cfile)

    #apply overrides from command line
    overrides = overrides or []
    for opt in overrides:
        parts = opt.split("=", 1)
        if len(parts) != 2:
            die('Invalid option specification: %s\nUse OPT=VALUE' % opt)
        key, value = parts
        cp.set('altsrc', key, value)

    #generate config dictionary
    config = dict(config_defaults)  #copy
    for key in cp.options('altsrc'):
        if key in config_int_opts:
            config[key] = cp.getint('altsrc', key)
        elif key in config_bool_opts:
            config[key] = cp.getboolean('altsrc', key)
        else:
            config[key] = cp.get('altsrc', key)

    #sanity checks
    if not os.path.isdir(config['stagedir']):
        die("No such directory: %s" % config['stagedir'])

    return config


class Stager(object):

    def __init__(self, options):
        self.options = options
        self.logger = logging.getLogger("altsrc")
        self.srpm = options.source
        #TODO - support pulling srpm from Brew
        if not os.path.isfile(self.srpm):
            die("No such file: %s", self.srpm)

    def run(self):
        self.read_srpm()
        self.check_package()
        self.make_workdir()
        self.sync_repo()
        self.clone_repo()
        self.import_srpm()
        self.debrand()
        self.notify()

    def read_srpm(self):
        self.logger.info('Reading source rpm: %s', self.srpm)
        h = koji.get_rpm_header(self.srpm)
        self.headers = h
        if h[rpm.RPMTAG_SOURCEPACKAGE] != 1:
            die("%s is not a source package" % self.srpm)
        data = koji.get_header_fields(h, ['name','version','release'])
        self.nvr = "%(name)s-%(version)s-%(release)s" % data
        self.package = data['name']

    def check_package(self):
        """Check whitelist/blacklist and load any package rules"""

        whitelist = self.options.config['whitelist'].split()
        if whitelist:
            whitelisted = koji.util.multi_fnmatch(self, self.package, whitelist)
        else:
            whitelisted = False
        if not whitelisted:
            blacklist = self.options.config['blacklist'].split()
            if blacklist and koji.util.multi_fnmatch(self, self.package, blacklist):
                die('Blacklisted package: %s' % self.package)
        # TODO - load package rules

    def make_workdir(self):
        dirname = os.path.join(self.options.config['stagedir'], self.nvr)
        letter = self.package[0]
        if not letter.isalpha():
            letter = "_"
        parts = [
            os.path.join(self.options.config['stagedir']),
            letter,
            self.package,
            self.nvr,
        ]
        dirname = os.path.join(*parts)
        self.logger.info('Creating working directory: %s', dirname)
        if os.path.islink(dirname):
            die("%s is a symlink" % dirname)
        elif os.path.isdir(dirname):
            # TODO - more sanity checks
            if self.options.force:
                self.logger.warn("Overwriting existing workdir: %s",  dirname)
                # TODO - back up first
                koji.util.rmtree(dirname)
            else:
                die("Work directory %s directory exists, use --force to overwrite." % dirname)
        elif os.path.exists(dirname):
            die("%s exists and is not a directory" % dirname)
        koji.ensuredir(dirname)
        self.workdir = dirname

    def sync_repo(self):
        # TODO
        pass

    def clone_repo(self):
        """Clone master repo into working directory"""
        logname = os.path.join(self.workdir, 'clone.log')
        fo = file(logname, 'wb')
        src = os.path.join(self.options.config['gitdir'], "%s.git" % self.package)
        dst = os.path.join(self.workdir, "%s.git" % self.package)
        cmd = ['git', 'clone', '--shared', '--bare', '-v', src, dst]
        # [??] use --shared?
        # TODO - template? git config?
        # TODO - committer data?
        proc = subprocess.Popen(cmd, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        ret = proc.wait()
        if ret:
            die("command failed: %r" % cmd)

    def import_srpm(self):
        """Import our srpm on the specified branch"""
        # first we need a temporary non-bare checkout to work with
        logname = os.path.join(self.workdir, 'import.log')
        fo = file(logname, 'wb')

        src = os.path.join(self.workdir, "%s.git" % self.package)
        dst = os.path.join(self.workdir, "tmp.%s" % self.package)
        cmd = ['git', 'clone', '--local', '-v', src, dst]
        proc = subprocess.Popen(cmd, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        proc.wait() and die("command failed: %r" % cmd)

        #switch branch
        #TODO - smarter sanity checks
        cmd = ['git', 'checkout', self.options.branch]
        #XXX - should be more paranoid here
        proc = subprocess.Popen(cmd, cwd=dst, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        proc.wait() and die("command failed: %r" % cmd)

        #explode our srpm
        wipe_git_dir(dst)
        explode_srpm(self.srpm, dst, logfile=fo)

        cmd = ['git', 'add', '-A', '.']
        proc = subprocess.Popen(cmd, cwd=dst, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        proc.wait() and die("command failed: %r" % cmd)

        #TODO - deal with lookaside

        cmd = ['git', 'commit', '-m', 'import %s' % self.nvr]
        proc = subprocess.Popen(cmd, cwd=dst, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        proc.wait() and die("command failed: %r" % cmd)

        #push back to our bare git directory
        cmd = ['git', 'push', 'origin', self.options.branch]
        proc = subprocess.Popen(cmd, cwd=dst, stdout=fo, stderr=subprocess.STDOUT, close_fds=True)
        proc.wait() and die("command failed: %r" % cmd)

        #remove temp dir
        koji.util.rmtree(dst)

    def debrand(self):
        pass
        #TODO


    def notify(self):
        pass
        #TODO


def explode_srpm(srpm, destdir=None, logfile=None):
    # explode our srpm to the given directory
    h = koji.get_rpm_header(srpm)
    if h[rpm.RPMTAG_SOURCEPACKAGE] != 1:
        # we checked this earlier, but since we're about to rpm -i it,
        # let's check again
        die("%s is not a source package" % srpm)
    if destdir is None:
        destdir = os.getcwd()
    else:
        destdir = os.path.abspath(destdir)
        koji.ensuredir(destdir)
    cmd = ['rpm', '--nosignature', '-i', '--define', '_topdir %s' % destdir, srpm]
    #print "Running: %r" % cmd
    #TODO: logfile
    popts = {'close_fds':True}
    if logfile:
        popts['stdout'] = logfile
        popts['stderr'] = subprocess.STDOUT
    proc = subprocess.Popen(cmd, **popts)
    ret = proc.wait()
    if ret:
        die("command failed: %r" % cmd)


def wipe_git_dir(dirname):
    for fn in os.listdir(dirname):
        if fn == '.git':
            continue
        path = os.path.join(dirname, fn)
        if os.path.isdir(path):
            koji.rmtree(path)
        else:
            os.unlink(path)


def die(msg):
    print msg
    sys.exit(1)


def setup_logging(options):
    logger = logging.getLogger("altsrc")
    handler = logging.StreamHandler(sys.stderr)
    handler.setFormatter(logging.Formatter(options.config['log_format']))
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    if options.config['log_file']:
        handler = logging.handlers.RotatingFileHandler(options.config['log_file'])
        handler.setFormatter(logging.Formatter(options.config['log_format']))
        handler.setLevel(logging.DEBUG)
        logger.addHandler(handler)
    level = options.config['log_level']
    if options.debug:
        level = 'DEBUG'
    elif options.verbose:
        level = 'INFO'
    elif options.quiet:
        level = 'ERROR'
    lvl = getattr(logging, level, None)
    if lvl is None:
        die("Invalid log level: %s" % options.config['log_level'])
    logger.setLevel(lvl)
    # TODO - log file?
    # TODO - setup koji's logger?


if __name__ == '__main__':
    options = get_options()
    setup_logging(options)
    stg = Stager(options)
    stg.run()
    #TODO - trap errors and notify

# the end
